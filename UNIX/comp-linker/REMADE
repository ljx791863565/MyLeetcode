《程序员的自我修养 -- 链接、装载与库》

gcc 编译的四个步骤

//预处理
$ gcc -E test.c -o test.i
预处理过程中主要助理源码中以 # 开头的预编译指令
** 将所有的"#define" 删除，并且展开所有的宏定义
** 处理所有的条件预编译指令。比如"#if" "#ifdef" "#ifndef" "#elif" "#else" "#endif"
** 处理所有的 "#include" 预编译指令。将被包含的文件递归插入到该指令位置（即指令内部可能也有"#include"）
** 删除所有的注释 "/* */" "//"
预处理后得到的.i文件不包含任何宏定义了

//编译
$ gcc -S test.i -o test.s
将预处理完的文件进行一些列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件
这个生成的.s文件是汇编文件
现在的GCC把预处理和编译合成一个步骤
$ gcc -S test.c -o test.s

//汇编
$ gcc -c test.s -o test.o
汇编器将汇编代码转换成机器可以执行的指令，每一句汇编语句几乎对应一条机器指令。（二进制）
汇编器只需要根据汇编指令和机器指令对照表一一翻译就可以了
也可以从源文件一步到这里
$ gcc -c test.c test.o

//链接
$ gcc -o test.o test
...这里我还不太懂，等我弄明白了静态库动态库之类的再来补充。。。



编译器在编译过程中一般要经过下面步骤得到汇编代码：

扫描 语法分析 语义分析 源代码优化 代码生成 目标代码优化

扫描器 (Scanner)

词法分析器(Lexical Analyzer)：运用 有限状态机(Finite State Machine)算法将扫描进来的源代码分割成一系列 Token
	关键字 标识符 字面量 特殊符号
	工具 lex

语法分析器(Grammar Parser)：对Token进行分析，得到Syntax Tree。整个分析过程采用了 上下文无关语法(Context-free Grammar)
	工具 yacc (Yet Another Compiler Compiler) 
	对于不同的编程语言，编译器的开发者只需要改变语法规则，而不需要对每一个编译器写一个语法分析器。
	又被称作 "编译器编译器(Compiler Compiler)"

语义分析器(Semantic Analyzer)：
	语法分析器只是把语法树的构建，并不会检查语法是否有意义
	比如 指针相乘没有意义但语法上是合法的
	静态语义：Static Semantic 在编译期可以确定的语义 包括 声明 类型的匹配 类型的转换等
	动态语义：Dynamic Semantic 需要在运行时才能确定的语义 比如将0作为除数会报错
	
源码级优化器(Source Code Optimizer):
	
代码生成器
	
